{
  "version": 3,
  "sources": ["../../gsap/MotionPathPlugin.js"],
  "sourcesContent": ["/*!\r\n * MotionPathPlugin 3.13.0\r\n * https://gsap.com\r\n *\r\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\r\n * Subject to the terms at https://gsap.com/standard-license\r\n * @author: Jack Doyle, jack@greensock.com\r\n*/\r\n\r\n/* eslint-disable */\r\nimport { getRawPath, cacheRawPathMeasurements, getPositionOnPath, pointsToSegment, flatPointsToSegment, sliceRawPath, stringToRawPath, rawPathToString, transformRawPath, convertToPath as _convertToPath } from \"./utils/paths.js\";\r\nimport { getGlobalMatrix } from \"./utils/matrix.js\";\r\n\r\nvar _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\r\n    _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\r\n    _DEG2RAD = Math.PI / 180,\r\n    gsap,\r\n    PropTween,\r\n    _getUnit,\r\n    _toArray,\r\n    _getStyleSaver,\r\n    _reverting,\r\n    _getGSAP = function _getGSAP() {\r\n  return gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap;\r\n},\r\n    _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {\r\n  //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\r\n  var l = values.length,\r\n      si = mode === 2 ? 0 : mode,\r\n      i = 0,\r\n      v;\r\n\r\n  for (; i < l; i++) {\r\n    segment[si] = v = parseFloat(values[i][property]);\r\n    mode === 2 && (segment[si + 1] = 0);\r\n    si += 2;\r\n  }\r\n\r\n  return segment;\r\n},\r\n    _getPropNum = function _getPropNum(target, prop, unit) {\r\n  return parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0;\r\n},\r\n    _relativize = function _relativize(segment) {\r\n  var x = segment[0],\r\n      y = segment[1],\r\n      i;\r\n\r\n  for (i = 2; i < segment.length; i += 2) {\r\n    x = segment[i] += x;\r\n    y = segment[i + 1] += y;\r\n  }\r\n},\r\n    // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\r\n// _quadToCubic = points => {\r\n// \tlet cubic = [],\r\n// \t\tl = points.length - 1,\r\n// \t\ti = 1,\r\n// \t\ta, b, c;\r\n// \tfor (; i < l; i+=2) {\r\n// \t\ta = points[i-1];\r\n// \t\tb = points[i];\r\n// \t\tc = points[i+1];\r\n// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\r\n// \t}\r\n// \tcubic.push(points[l]);\r\n// \treturn cubic;\r\n// },\r\n_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {\r\n  if (vars.type === \"cubic\") {\r\n    segment = [segment];\r\n  } else {\r\n    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\r\n    vars.relative && _relativize(segment);\r\n    var pointFunc = y ? pointsToSegment : flatPointsToSegment;\r\n    segment = [pointFunc(segment, vars.curviness)];\r\n  }\r\n\r\n  segment = slicer(_align(segment, target, vars));\r\n\r\n  _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\r\n\r\n  y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\r\n  return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\r\n},\r\n    _emptyFunc = function _emptyFunc(v) {\r\n  return v;\r\n},\r\n    _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\r\n    _originToPoint = function _originToPoint(element, origin, parentMatrix) {\r\n  // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\r\n  var m = getGlobalMatrix(element),\r\n      x = 0,\r\n      y = 0,\r\n      svg;\r\n\r\n  if ((element.tagName + \"\").toLowerCase() === \"svg\") {\r\n    svg = element.viewBox.baseVal;\r\n    svg.width || (svg = {\r\n      width: +element.getAttribute(\"width\"),\r\n      height: +element.getAttribute(\"height\")\r\n    });\r\n  } else {\r\n    svg = origin && element.getBBox && element.getBBox();\r\n  }\r\n\r\n  if (origin && origin !== \"auto\") {\r\n    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\r\n    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\r\n  }\r\n\r\n  return parentMatrix.apply(x || y ? m.apply({\r\n    x: x,\r\n    y: y\r\n  }) : {\r\n    x: m.e,\r\n    y: m.f\r\n  });\r\n},\r\n    _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {\r\n  var parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\r\n      m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\r\n      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\r\n      _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix),\r\n      x = _originToPoint2.x,\r\n      y = _originToPoint2.y,\r\n      p;\r\n\r\n  m.e = m.f = 0;\r\n\r\n  if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\r\n    p = toElement.getAttribute(\"d\").match(_numExp) || [];\r\n    p = m.apply({\r\n      x: +p[0],\r\n      y: +p[1]\r\n    });\r\n    x += p.x;\r\n    y += p.y;\r\n  } //if (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {\r\n\r\n\r\n  if (p) {\r\n    p = m.apply(toElement.getBBox());\r\n    x -= p.x;\r\n    y -= p.y;\r\n  }\r\n\r\n  m.e = x - fromPoint.x;\r\n  m.f = y - fromPoint.y;\r\n  return m;\r\n},\r\n    _align = function _align(rawPath, target, _ref) {\r\n  var align = _ref.align,\r\n      matrix = _ref.matrix,\r\n      offsetX = _ref.offsetX,\r\n      offsetY = _ref.offsetY,\r\n      alignOrigin = _ref.alignOrigin;\r\n\r\n  var x = rawPath[0][0],\r\n      y = rawPath[0][1],\r\n      curX = _getPropNum(target, \"x\"),\r\n      curY = _getPropNum(target, \"y\"),\r\n      alignTarget,\r\n      m,\r\n      p;\r\n\r\n  if (!rawPath || !rawPath.length) {\r\n    return getRawPath(\"M0,0L0,0\");\r\n  }\r\n\r\n  if (align) {\r\n    if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\r\n      transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\r\n    } else {\r\n      if (alignOrigin && alignOrigin[2] !== false) {\r\n        gsap.set(target, {\r\n          transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\r\n        });\r\n      } else {\r\n        alignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\r\n      }\r\n\r\n      m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\r\n      p = m.apply({\r\n        x: x,\r\n        y: y\r\n      });\r\n      transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\r\n    }\r\n  }\r\n\r\n  if (matrix) {\r\n    transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\r\n  } else if (offsetX || offsetY) {\r\n    transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\r\n  }\r\n\r\n  return rawPath;\r\n},\r\n    _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {\r\n  var cache = target._gsap,\r\n      harness = cache.harness,\r\n      alias = harness && harness.aliases && harness.aliases[property],\r\n      prop = alias && alias.indexOf(\",\") < 0 ? alias : property,\r\n      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\r\n  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\r\n  pt.path = rawPath;\r\n  pt.pp = pathProperty;\r\n\r\n  plugin._props.push(prop);\r\n},\r\n    _sliceModifier = function _sliceModifier(start, end) {\r\n  return function (rawPath) {\r\n    return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;\r\n  };\r\n};\r\n\r\nexport var MotionPathPlugin = {\r\n  version: \"3.13.0\",\r\n  name: \"motionPath\",\r\n  register: function register(core, Plugin, propTween) {\r\n    gsap = core;\r\n    _getUnit = gsap.utils.getUnit;\r\n    _toArray = gsap.utils.toArray;\r\n    _getStyleSaver = gsap.core.getStyleSaver;\r\n\r\n    _reverting = gsap.core.reverting || function () {};\r\n\r\n    PropTween = propTween;\r\n  },\r\n  init: function init(target, vars, tween) {\r\n    if (!gsap) {\r\n      console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\r\n      return false;\r\n    }\r\n\r\n    if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\r\n      vars = {\r\n        path: vars\r\n      };\r\n    }\r\n\r\n    var rawPaths = [],\r\n        _vars = vars,\r\n        path = _vars.path,\r\n        autoRotate = _vars.autoRotate,\r\n        unitX = _vars.unitX,\r\n        unitY = _vars.unitY,\r\n        x = _vars.x,\r\n        y = _vars.y,\r\n        firstObj = path[0],\r\n        slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1),\r\n        rawPath,\r\n        p;\r\n\r\n    this.rawPaths = rawPaths;\r\n    this.target = target;\r\n    this.tween = tween;\r\n    this.styles = _getStyleSaver && _getStyleSaver(target, \"transform\");\r\n\r\n    if (this.rotate = autoRotate || autoRotate === 0) {\r\n      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\r\n      this.rOffset = parseFloat(autoRotate) || 0;\r\n      this.radians = !!vars.useRadians;\r\n      this.rProp = vars.rotation || \"rotation\"; // rotation property\r\n\r\n      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\r\n\r\n      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\r\n    }\r\n\r\n    if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\r\n      for (p in firstObj) {\r\n        if (!x && ~_xProps.indexOf(p)) {\r\n          x = p;\r\n        } else if (!y && ~_yProps.indexOf(p)) {\r\n          y = p;\r\n        }\r\n      }\r\n\r\n      if (x && y) {\r\n        //correlated values\r\n        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\r\n      } else {\r\n        x = y = 0;\r\n      }\r\n\r\n      for (p in firstObj) {\r\n        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\r\n      }\r\n    } else {\r\n      rawPath = slicer(_align(getRawPath(vars.path), target, vars));\r\n      cacheRawPathMeasurements(rawPath, vars.resolution);\r\n      rawPaths.push(rawPath);\r\n\r\n      _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\r\n\r\n      _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\r\n    }\r\n\r\n    tween.vars.immediateRender && this.render(tween.progress(), this);\r\n  },\r\n  render: function render(ratio, data) {\r\n    var rawPaths = data.rawPaths,\r\n        i = rawPaths.length,\r\n        pt = data._pt;\r\n\r\n    if (data.tween._time || !_reverting()) {\r\n      if (ratio > 1) {\r\n        ratio = 1;\r\n      } else if (ratio < 0) {\r\n        ratio = 0;\r\n      }\r\n\r\n      while (i--) {\r\n        getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\r\n      }\r\n\r\n      while (pt) {\r\n        pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\r\n        pt = pt._next;\r\n      }\r\n\r\n      data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\r\n    } else {\r\n      data.styles.revert();\r\n    }\r\n  },\r\n  getLength: function getLength(path) {\r\n    return cacheRawPathMeasurements(getRawPath(path)).totalLength;\r\n  },\r\n  sliceRawPath: sliceRawPath,\r\n  getRawPath: getRawPath,\r\n  pointsToSegment: pointsToSegment,\r\n  stringToRawPath: stringToRawPath,\r\n  rawPathToString: rawPathToString,\r\n  transformRawPath: transformRawPath,\r\n  getGlobalMatrix: getGlobalMatrix,\r\n  getPositionOnPath: getPositionOnPath,\r\n  cacheRawPathMeasurements: cacheRawPathMeasurements,\r\n  convertToPath: function convertToPath(targets, swap) {\r\n    return _toArray(targets).map(function (target) {\r\n      return _convertToPath(target, swap !== false);\r\n    });\r\n  },\r\n  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {\r\n    var m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\r\n    return point ? m.apply(point) : m;\r\n  },\r\n  getAlignMatrix: _getAlignMatrix,\r\n  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\r\n    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\r\n\r\n    return {\r\n      x: m.e,\r\n      y: m.f\r\n    };\r\n  },\r\n  arrayToRawPath: function arrayToRawPath(value, vars) {\r\n    vars = vars || {};\r\n\r\n    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\r\n\r\n    vars.relative && _relativize(segment);\r\n    return [vars.type === \"cubic\" ? segment : pointsToSegment(segment, vars.curviness)];\r\n  }\r\n};\r\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\r\nexport { MotionPathPlugin as default };"],
  "mappings": "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",
  "names": ["_getGSAP", "_populateSegmentFromArray", "_getPropNum", "_relativize", "_segmentToRawPath", "_emptyFunc", "_originToPoint", "_getAlignMatrix", "_originToPoint2", "_align", "_addDimensionalPropTween", "_sliceModifier", "convertToPath"]
}
