{
  "version": 3,
  "sources": ["../../gsap/SplitText.js"],
  "sourcesContent": ["/*!\r\n * SplitText 3.13.0\r\n * https://gsap.com\r\n *\r\n * @license Copyright 2025, GreenSock. All rights reserved. Subject to the terms at https://gsap.com/standard-license.\r\n * @author: Jack Doyle\r\n */\r\n\r\nlet gsap, _fonts, _coreInitted, _initIfNecessary = () => _coreInitted || SplitText.register(window.gsap), _charSegmenter = typeof Intl !== \"undefined\" ? new Intl.Segmenter() : 0, _toArray = (r) => typeof r === \"string\" ? _toArray(document.querySelectorAll(r)) : \"length\" in r ? Array.from(r) : [r], _elements = (targets) => _toArray(targets).filter((e) => e instanceof HTMLElement), _emptyArray = [], _context = function() {\r\n}, _spacesRegEx = /\\s+/g, _emojiSafeRegEx = new RegExp(\"\\\\p{RI}\\\\p{RI}|\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?(\\\\u{200D}\\\\p{Emoji}(\\\\p{EMod}|\\\\u{FE0F}\\\\u{20E3}?|[\\\\u{E0020}-\\\\u{E007E}]+\\\\u{E007F})?)*|.\", \"gu\"), _emptyBounds = { left: 0, top: 0, width: 0, height: 0 }, _stretchToFitSpecialChars = (collection, specialCharsRegEx) => {\r\n  if (specialCharsRegEx) {\r\n    let charsFound = new Set(collection.join(\"\").match(specialCharsRegEx) || _emptyArray), i = collection.length, slots, word, char, combined;\r\n    if (charsFound.size) {\r\n      while (--i > -1) {\r\n        word = collection[i];\r\n        for (char of charsFound) {\r\n          if (char.startsWith(word) && char.length > word.length) {\r\n            slots = 0;\r\n            combined = word;\r\n            while (char.startsWith(combined += collection[i + ++slots]) && combined.length < char.length) {\r\n            }\r\n            if (slots && combined.length === char.length) {\r\n              collection[i] = char;\r\n              collection.splice(i + 1, slots);\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return collection;\r\n}, _disallowInline = (element) => window.getComputedStyle(element).display === \"inline\" && (element.style.display = \"inline-block\"), _insertNodeBefore = (newChild, parent, existingChild) => parent.insertBefore(typeof newChild === \"string\" ? document.createTextNode(newChild) : newChild, existingChild), _getWrapper = (type, config, collection) => {\r\n  let className = config[type + \"sClass\"] || \"\", { tag = \"div\", aria = \"auto\", propIndex = false } = config, display = type === \"line\" ? \"block\" : \"inline-block\", incrementClass = className.indexOf(\"++\") > -1, wrapper = (text) => {\r\n    let el = document.createElement(tag), i = collection.length + 1;\r\n    className && (el.className = className + (incrementClass ? \" \" + className + i : \"\"));\r\n    propIndex && el.style.setProperty(\"--\" + type, i + \"\");\r\n    aria !== \"none\" && el.setAttribute(\"aria-hidden\", \"true\");\r\n    if (tag !== \"span\") {\r\n      el.style.position = \"relative\";\r\n      el.style.display = display;\r\n    }\r\n    el.textContent = text;\r\n    collection.push(el);\r\n    return el;\r\n  };\r\n  incrementClass && (className = className.replace(\"++\", \"\"));\r\n  wrapper.collection = collection;\r\n  return wrapper;\r\n}, _getLineWrapper = (element, nodes, config, collection) => {\r\n  let lineWrapper = _getWrapper(\"line\", config, collection), textAlign = window.getComputedStyle(element).textAlign || \"left\";\r\n  return (startIndex, endIndex) => {\r\n    let newLine = lineWrapper(\"\");\r\n    newLine.style.textAlign = textAlign;\r\n    element.insertBefore(newLine, nodes[startIndex]);\r\n    for (; startIndex < endIndex; startIndex++) {\r\n      newLine.appendChild(nodes[startIndex]);\r\n    }\r\n    newLine.normalize();\r\n  };\r\n}, _splitWordsAndCharsRecursively = (element, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, isNested) => {\r\n  var _a;\r\n  let nodes = Array.from(element.childNodes), i = 0, { wordDelimiter, reduceWhiteSpace = true, prepareText } = config, elementBounds = element.getBoundingClientRect(), lastBounds = elementBounds, isPreformatted = !reduceWhiteSpace && window.getComputedStyle(element).whiteSpace.substring(0, 3) === \"pre\", ignoredPreviousSibling = 0, wordsCollection = wordWrapper.collection, wordDelimIsNotSpace, wordDelimString, wordDelimSplitter, curNode, words, curWordEl, startsWithSpace, endsWithSpace, j, bounds, curWordChars, clonedNode, curSubNode, tempSubNode, curTextContent, wordText, lastWordText, k;\r\n  if (typeof wordDelimiter === \"object\") {\r\n    wordDelimSplitter = wordDelimiter.delimiter || wordDelimiter;\r\n    wordDelimString = wordDelimiter.replaceWith || \"\";\r\n  } else {\r\n    wordDelimString = wordDelimiter === \"\" ? \"\" : wordDelimiter || \" \";\r\n  }\r\n  wordDelimIsNotSpace = wordDelimString !== \" \";\r\n  for (; i < nodes.length; i++) {\r\n    curNode = nodes[i];\r\n    if (curNode.nodeType === 3) {\r\n      curTextContent = curNode.textContent || \"\";\r\n      if (reduceWhiteSpace) {\r\n        curTextContent = curTextContent.replace(_spacesRegEx, \" \");\r\n      } else if (isPreformatted) {\r\n        curTextContent = curTextContent.replace(/\\n/g, wordDelimString + \"\\n\");\r\n      }\r\n      prepareText && (curTextContent = prepareText(curTextContent, element));\r\n      curNode.textContent = curTextContent;\r\n      words = wordDelimString || wordDelimSplitter ? curTextContent.split(wordDelimSplitter || wordDelimString) : curTextContent.match(charSplitRegEx) || _emptyArray;\r\n      lastWordText = words[words.length - 1];\r\n      endsWithSpace = wordDelimIsNotSpace ? lastWordText.slice(-1) === \" \" : !lastWordText;\r\n      lastWordText || words.pop();\r\n      lastBounds = elementBounds;\r\n      startsWithSpace = wordDelimIsNotSpace ? words[0].charAt(0) === \" \" : !words[0];\r\n      startsWithSpace && _insertNodeBefore(\" \", element, curNode);\r\n      words[0] || words.shift();\r\n      _stretchToFitSpecialChars(words, specialCharsRegEx);\r\n      deepSlice && isNested || (curNode.textContent = \"\");\r\n      for (j = 1; j <= words.length; j++) {\r\n        wordText = words[j - 1];\r\n        if (!reduceWhiteSpace && isPreformatted && wordText.charAt(0) === \"\\n\") {\r\n          (_a = curNode.previousSibling) == null ? void 0 : _a.remove();\r\n          _insertNodeBefore(document.createElement(\"br\"), element, curNode);\r\n          wordText = wordText.slice(1);\r\n        }\r\n        if (!reduceWhiteSpace && wordText === \"\") {\r\n          _insertNodeBefore(wordDelimString, element, curNode);\r\n        } else if (wordText === \" \") {\r\n          element.insertBefore(document.createTextNode(\" \"), curNode);\r\n        } else {\r\n          wordDelimIsNotSpace && wordText.charAt(0) === \" \" && _insertNodeBefore(\" \", element, curNode);\r\n          if (ignoredPreviousSibling && j === 1 && !startsWithSpace && wordsCollection.indexOf(ignoredPreviousSibling.parentNode) > -1) {\r\n            curWordEl = wordsCollection[wordsCollection.length - 1];\r\n            curWordEl.appendChild(document.createTextNode(charWrapper ? \"\" : wordText));\r\n          } else {\r\n            curWordEl = wordWrapper(charWrapper ? \"\" : wordText);\r\n            _insertNodeBefore(curWordEl, element, curNode);\r\n            ignoredPreviousSibling && j === 1 && !startsWithSpace && curWordEl.insertBefore(ignoredPreviousSibling, curWordEl.firstChild);\r\n          }\r\n          if (charWrapper) {\r\n            curWordChars = _charSegmenter ? _stretchToFitSpecialChars([..._charSegmenter.segment(wordText)].map((s) => s.segment), specialCharsRegEx) : wordText.match(charSplitRegEx) || _emptyArray;\r\n            for (k = 0; k < curWordChars.length; k++) {\r\n              curWordEl.appendChild(curWordChars[k] === \" \" ? document.createTextNode(\" \") : charWrapper(curWordChars[k]));\r\n            }\r\n          }\r\n          if (deepSlice && isNested) {\r\n            curTextContent = curNode.textContent = curTextContent.substring(wordText.length + 1, curTextContent.length);\r\n            bounds = curWordEl.getBoundingClientRect();\r\n            if (bounds.top > lastBounds.top && bounds.left <= lastBounds.left) {\r\n              clonedNode = element.cloneNode();\r\n              curSubNode = element.childNodes[0];\r\n              while (curSubNode && curSubNode !== curWordEl) {\r\n                tempSubNode = curSubNode;\r\n                curSubNode = curSubNode.nextSibling;\r\n                clonedNode.appendChild(tempSubNode);\r\n              }\r\n              element.parentNode.insertBefore(clonedNode, element);\r\n              prepForCharsOnly && _disallowInline(clonedNode);\r\n            }\r\n            lastBounds = bounds;\r\n          }\r\n          if (j < words.length || endsWithSpace) {\r\n            _insertNodeBefore(j >= words.length ? \" \" : wordDelimIsNotSpace && wordText.slice(-1) === \" \" ? \" \" + wordDelimString : wordDelimString, element, curNode);\r\n          }\r\n        }\r\n      }\r\n      element.removeChild(curNode);\r\n      ignoredPreviousSibling = 0;\r\n    } else if (curNode.nodeType === 1) {\r\n      if (ignore && ignore.indexOf(curNode) > -1) {\r\n        wordsCollection.indexOf(curNode.previousSibling) > -1 && wordsCollection[wordsCollection.length - 1].appendChild(curNode);\r\n        ignoredPreviousSibling = curNode;\r\n      } else {\r\n        _splitWordsAndCharsRecursively(curNode, config, wordWrapper, charWrapper, prepForCharsOnly, deepSlice, ignore, charSplitRegEx, specialCharsRegEx, true);\r\n        ignoredPreviousSibling = 0;\r\n      }\r\n      prepForCharsOnly && _disallowInline(curNode);\r\n    }\r\n  }\r\n};\r\nconst _SplitText = class _SplitText {\r\n  constructor(elements, config) {\r\n    this.isSplit = false;\r\n    _initIfNecessary();\r\n    this.elements = _elements(elements);\r\n    this.chars = [];\r\n    this.words = [];\r\n    this.lines = [];\r\n    this.masks = [];\r\n    this.vars = config;\r\n    this._split = () => this.isSplit && this.split(this.vars);\r\n    let orig = [], timerId, checkWidths = () => {\r\n      let i = orig.length, o;\r\n      while (i--) {\r\n        o = orig[i];\r\n        let w = o.element.offsetWidth;\r\n        if (w !== o.width) {\r\n          o.width = w;\r\n          this._split();\r\n          return;\r\n        }\r\n      }\r\n    };\r\n    this._data = { orig, obs: typeof ResizeObserver !== \"undefined\" && new ResizeObserver(() => {\r\n      clearTimeout(timerId);\r\n      timerId = setTimeout(checkWidths, 200);\r\n    }) };\r\n    _context(this);\r\n    this.split(config);\r\n  }\r\n  split(config) {\r\n    this.isSplit && this.revert();\r\n    this.vars = config = config || this.vars || {};\r\n    let { type = \"chars,words,lines\", aria = \"auto\", deepSlice = true, smartWrap, onSplit, autoSplit = false, specialChars, mask } = this.vars, splitLines = type.indexOf(\"lines\") > -1, splitCharacters = type.indexOf(\"chars\") > -1, splitWords = type.indexOf(\"words\") > -1, onlySplitCharacters = splitCharacters && !splitWords && !splitLines, specialCharsRegEx = specialChars && (\"push\" in specialChars ? new RegExp(\"(?:\" + specialChars.join(\"|\") + \")\", \"gu\") : specialChars), finalCharSplitRegEx = specialCharsRegEx ? new RegExp(specialCharsRegEx.source + \"|\" + _emojiSafeRegEx.source, \"gu\") : _emojiSafeRegEx, ignore = !!config.ignore && _elements(config.ignore), { orig, animTime, obs } = this._data, onSplitResult;\r\n    if (splitCharacters || splitWords || splitLines) {\r\n      this.elements.forEach((element, index) => {\r\n        orig[index] = {\r\n          element,\r\n          html: element.innerHTML,\r\n          ariaL: element.getAttribute(\"aria-label\"),\r\n          ariaH: element.getAttribute(\"aria-hidden\")\r\n        };\r\n        aria === \"auto\" ? element.setAttribute(\"aria-label\", (element.textContent || \"\").trim()) : aria === \"hidden\" && element.setAttribute(\"aria-hidden\", \"true\");\r\n        let chars = [], words = [], lines = [], charWrapper = splitCharacters ? _getWrapper(\"char\", config, chars) : null, wordWrapper = _getWrapper(\"word\", config, words), i, curWord, smartWrapSpan, nextSibling;\r\n        _splitWordsAndCharsRecursively(element, config, wordWrapper, charWrapper, onlySplitCharacters, deepSlice && (splitLines || onlySplitCharacters), ignore, finalCharSplitRegEx, specialCharsRegEx, false);\r\n        if (splitLines) {\r\n          let nodes = _toArray(element.childNodes), wrapLine = _getLineWrapper(element, nodes, config, lines), curNode, toRemove = [], lineStartIndex = 0, allBounds = nodes.map((n) => n.nodeType === 1 ? n.getBoundingClientRect() : _emptyBounds), lastBounds = _emptyBounds;\r\n          for (i = 0; i < nodes.length; i++) {\r\n            curNode = nodes[i];\r\n            if (curNode.nodeType === 1) {\r\n              if (curNode.nodeName === \"BR\") {\r\n                toRemove.push(curNode);\r\n                wrapLine(lineStartIndex, i + 1);\r\n                lineStartIndex = i + 1;\r\n                lastBounds = allBounds[lineStartIndex];\r\n              } else {\r\n                if (i && allBounds[i].top > lastBounds.top && allBounds[i].left <= lastBounds.left) {\r\n                  wrapLine(lineStartIndex, i);\r\n                  lineStartIndex = i;\r\n                }\r\n                lastBounds = allBounds[i];\r\n              }\r\n            }\r\n          }\r\n          lineStartIndex < i && wrapLine(lineStartIndex, i);\r\n          toRemove.forEach((el) => {\r\n            var _a;\r\n            return (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);\r\n          });\r\n        }\r\n        if (!splitWords) {\r\n          for (i = 0; i < words.length; i++) {\r\n            curWord = words[i];\r\n            if (splitCharacters || !curWord.nextSibling || curWord.nextSibling.nodeType !== 3) {\r\n              if (smartWrap && !splitLines) {\r\n                smartWrapSpan = document.createElement(\"span\");\r\n                smartWrapSpan.style.whiteSpace = \"nowrap\";\r\n                while (curWord.firstChild) {\r\n                  smartWrapSpan.appendChild(curWord.firstChild);\r\n                }\r\n                curWord.replaceWith(smartWrapSpan);\r\n              } else {\r\n                curWord.replaceWith(...curWord.childNodes);\r\n              }\r\n            } else {\r\n              nextSibling = curWord.nextSibling;\r\n              if (nextSibling && nextSibling.nodeType === 3) {\r\n                nextSibling.textContent = (curWord.textContent || \"\") + (nextSibling.textContent || \"\");\r\n                curWord.remove();\r\n              }\r\n            }\r\n          }\r\n          words.length = 0;\r\n          element.normalize();\r\n        }\r\n        this.lines.push(...lines);\r\n        this.words.push(...words);\r\n        this.chars.push(...chars);\r\n      });\r\n      mask && this[mask] && this.masks.push(...this[mask].map((el) => {\r\n        let maskEl = el.cloneNode();\r\n        el.replaceWith(maskEl);\r\n        maskEl.appendChild(el);\r\n        el.className && (maskEl.className = el.className.replace(/(\\b\\w+\\b)/g, \"$1-mask\"));\r\n        maskEl.style.overflow = \"clip\";\r\n        return maskEl;\r\n      }));\r\n    }\r\n    this.isSplit = true;\r\n    _fonts && (autoSplit ? _fonts.addEventListener(\"loadingdone\", this._split) : _fonts.status === \"loading\" && console.warn(\"SplitText called before fonts loaded\"));\r\n    if ((onSplitResult = onSplit && onSplit(this)) && onSplitResult.totalTime) {\r\n      this._data.anim = animTime ? onSplitResult.totalTime(animTime) : onSplitResult;\r\n    }\r\n    splitLines && autoSplit && this.elements.forEach((element, index) => {\r\n      orig[index].width = element.offsetWidth;\r\n      obs && obs.observe(element);\r\n    });\r\n    return this;\r\n  }\r\n  revert() {\r\n    var _a, _b;\r\n    let { orig, anim, obs } = this._data;\r\n    obs && obs.disconnect();\r\n    orig.forEach(({ element, html, ariaL, ariaH }) => {\r\n      element.innerHTML = html;\r\n      ariaL ? element.setAttribute(\"aria-label\", ariaL) : element.removeAttribute(\"aria-label\");\r\n      ariaH ? element.setAttribute(\"aria-hidden\", ariaH) : element.removeAttribute(\"aria-hidden\");\r\n    });\r\n    this.chars.length = this.words.length = this.lines.length = orig.length = this.masks.length = 0;\r\n    this.isSplit = false;\r\n    _fonts == null ? void 0 : _fonts.removeEventListener(\"loadingdone\", this._split);\r\n    if (anim) {\r\n      this._data.animTime = anim.totalTime();\r\n      anim.revert();\r\n    }\r\n    (_b = (_a = this.vars).onRevert) == null ? void 0 : _b.call(_a, this);\r\n    return this;\r\n  }\r\n  static create(elements, config) {\r\n    return new _SplitText(elements, config);\r\n  }\r\n  static register(core) {\r\n    gsap = gsap || core || window.gsap;\r\n    if (gsap) {\r\n      _toArray = gsap.utils.toArray;\r\n      _context = gsap.core.context || _context;\r\n    }\r\n    if (!_coreInitted && window.innerWidth > 0) {\r\n      _fonts = document.fonts;\r\n      _coreInitted = true;\r\n    }\r\n  }\r\n};\r\n_SplitText.version = \"3.13.0\";\r\nlet SplitText = _SplitText;\r\n\r\nexport { SplitText, SplitText as default };\r\n"],
  "mappings": "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",
  "names": ["_SplitText"]
}
